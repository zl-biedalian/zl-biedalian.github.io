(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{330:function(v,_,t){"use strict";t.r(_);var l=t(6),a=Object(l.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"内存泄漏"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#内存泄漏"}},[v._v("#")]),v._v(" 内存泄漏")]),v._v(" "),_("p",[v._v("指的是在不再使用的对象仍然占用内存，因此导致系统内存不断增加，最终可能导致系统内存不足崩溃。在JS中，这通常是由于某些对象没有正确地被垃圾回收机制回收。常见原因：")]),v._v(" "),_("ul",[_("li",[v._v("循环引用：当两个对象相互引用时，垃圾回收机制无法判断它们是否不再使用，从而导致内存泄漏。")]),v._v(" "),_("li",[v._v("未销毁的事件监听器：如果没有移除事件监听器，它们将一直在内存中保存，导致内存泄漏。")]),v._v(" "),_("li",[v._v("用闭包保存大量数据：闭包会保存其引用的变量，因此，如果闭包中保存了大量数据，这些数据将一直保存在内存中，导致内存泄漏。")]),v._v(" "),_("li",[v._v("未销毁的定时器：如果没有移除定时器，它们将一直在内存中保存，导致内存泄漏。")]),v._v(" "),_("li",[v._v("未正确释放内存：如果对象在创建后没有正确释放，它们将一直在内存中保存，导致内存泄漏。")]),v._v(" "),_("li",[v._v("未正确使用 weakMap：如果没有正确使用 weakMap，它们将不会被垃圾回收机制回收，从而导致内存泄漏。\n避免内存泄漏需要结合代码实际情况，注意在不再使用的对象时释放它们，并避免循环引用。比如对象置null")])]),v._v(" "),_("p",[_("br"),_("br"),_("br")]),v._v(" "),_("h2",{attrs:{id:"内存溢出"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#内存溢出"}},[v._v("#")]),v._v(" 内存溢出")]),v._v(" "),_("p",[v._v("指的是程序试图分配的内存超过了系统的可用内存，导致系统停止运行。在JS中，这通常是由于程序运行时间长、分配内存量大等因素导致。常见原因：")]),v._v(" "),_("ul",[_("li",[v._v("递归算法的堆栈溢出：递归算法的堆栈大小可能会变得很大，如果递归次数较多，容易导致内存溢出。")]),v._v(" "),_("li",[v._v("大量数据的处理：处理过多数据，特别是大量数组或大量字符串，容易导致内存溢出。")]),v._v(" "),_("li",[v._v("未正确释放内存：如果对象在创建后没有正确释放，它们将占用大量内存，从而导致内存溢出。")]),v._v(" "),_("li",[v._v("无限循环：无限循环可能会导致内存溢出。")]),v._v(" "),_("li",[v._v("创建过多对象：创建过多对象，特别是对象数量较多，容易导致内存溢出。\n要避免内存溢出，需要注意设计代码，使其在处理数据时不会占用过多内存，并且避免无限循环和创建过多对象。")])])])}),[],!1,null,null,null);_.default=a.exports}}]);