(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{348:function(n,t,r){"use strict";r.r(t);var e=r(6),a=Object(e.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h2",{attrs:{id:"js中存在的精度问题及解决方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js中存在的精度问题及解决方案"}},[n._v("#")]),n._v(" js中存在的精度问题及解决方案")]),n._v(" "),t("br"),n._v(" "),t("h3",{attrs:{id:"一、js中问什么会存在精度问题-为什么0-1-0-2-0-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、js中问什么会存在精度问题-为什么0-1-0-2-0-3"}},[n._v("#")]),n._v(" 一、js中问什么会存在精度问题：为什么0.1+0.2 ！= 0.3？")]),n._v(" "),t("p",[n._v("当将十进制数转换为二进制数时，0.1 和 0.2 都会产生无限循环的二进制表示形式。\n这是因为在二进制中，有些小数无法精确表示，就像在十进制中无法精确表示 1/3 一样。"),t("br"),t("br"),t("br"),n._v(" "),t("strong",[n._v("将 0.1 转换为二进制：")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("\n乘以 2，得到 0.2，整数部分为 0。\n乘以 2，得到 0.4，整数部分为 0。\n乘以 2，得到 0.8，整数部分为 0。\n乘以 2，得到 1.6，整数部分为 1。\n乘以 2，得到 1.2，整数部分为 1。\n乘以 2，得到 0.4，整数部分为 0。\n乘以 2，得到 0.8，整数部分为 0。\n乘以 2，得到 1.6，整数部分为 1。\n乘以 2，得到 1.2，整数部分为 1。\n继续该过程下去，得到无限循环的二进制表示形式：0.0001100110011...\n\n")])])]),t("p",[t("strong",[n._v("将 0.2 转换为二进制：")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("\n乘以 2，得到 0.4，整数部分为 0。\n乘以 2，得到 0.8，整数部分为 0。\n乘以 2，得到 1.6，整数部分为 1。\n乘以 2，得到 1.2，整数部分为 1。\n继续该过程下去，得到无限循环的二进制表示形式：0.001100110011...\n\n")])])]),t("p",[n._v("由于这种无限循环，将它们精确表示为二进制是不可能的.\n在计算机中，"),t("strong",[n._v("它们的二进制表示会被截断为有限位数")]),n._v("，从而引入舍入误差。\n"),t("br"),n._v("\n因此，在实际计算中，0.1 和 0.2 的精确值不是直接使用它们的二进制表示，而是使用近似值进行计算。 这导致了 0.1 + 0.2 的结果略微偏离于 0.3。\n"),t("br"),t("br")]),n._v(" "),t("h3",{attrs:{id:"二、关于精度的解决方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、关于精度的解决方案"}},[n._v("#")]),n._v(" 二、关于精度的解决方案")]),n._v(" "),t("br"),n._v(" "),t("p",[n._v("1、"),t("strong",[n._v("使用专门的高精度计算库")]),n._v("：可以使用第三方库或语言内置的高精度计算库，这些库提供了更精确的数值计算功能。\n例如，在 JavaScript 中，可以使用 Decimal.js、Big.js、math.js 等库来进行高精度计算。\n"),t("br")]),n._v(" "),t("p",[n._v("2、"),t("strong",[n._v("使用字符串表示数字实现精确计算")]),n._v("：如果不想依赖外部库，也可以手动实现高精度计算。\n一种常见的方法是使用字符串表示数字，然后编写相应的算法来进行精确计算。通过使用字符串表示，可以绕过浮点数的精度问题。 但是，这样做可能会降低计算速度和增加代码复杂性。")]),n._v(" "),t("br"),n._v("\n```javascript\n// 将数字转换为字符串\nfunction numberToString(num) {\n  return num.toString();\n}\n"),t("p",[n._v("// 去除字符串首尾的0\nfunction trimLeadingAndTrailingZeros(str) {\nreturn str.replace(/^0+|0+$/g, '');\n}")]),n._v(" "),t("p",[n._v("// 加法\nfunction add(a, b) {\nconst aStr = numberToString(a);\nconst bStr = numberToString(b);")]),n._v(" "),t("p",[n._v("let carry = 0; // 进位\nlet result = ''; // 结果")]),n._v(" "),t("p",[n._v("let i = aStr.length - 1; // 数字 a 的最后一位索引\nlet j = bStr.length - 1; // 数字 b 的最后一位索引")]),n._v(" "),t("p",[n._v("// 从后往前遍历 a 和 b 的每一位数字，进行相加\nwhile (i >= 0 || j >= 0 || carry > 0) {\nconst digitA = i >= 0 ? parseInt(aStr[i]) : 0; // 数字 a 的当前位数值，若索引越界则为0\nconst digitB = j >= 0 ? parseInt(bStr[j]) : 0; // 数字 b 的当前位数值，若索引越界则为0")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("// 计算当前位的和，加上进位\nconst sum = digitA + digitB + carry;\n// 更新进位\ncarry = Math.floor(sum / 10);\n// 将当前位的结果添加到结果字符串的开头\nresult = (sum % 10) + result;\n\n// 移动到下一位\ni--;\nj--;\n")])])]),t("p",[n._v("}")]),n._v(" "),t("p",[n._v("// 去除首尾无效的0，并返回结果\nreturn trimLeadingAndTrailingZeros(result);\n}")]),n._v(" "),t("p",[n._v("// 乘法\nfunction multiply(a, b) {\nconst aStr = numberToString(a);\nconst bStr = numberToString(b);")]),n._v(" "),t("p",[n._v("const products = []; // 存储各位乘积的临时数组")]),n._v(" "),t("p",[n._v("// 从 a 的最后一位开始遍历\nfor (let i = aStr.length - 1; i >= 0; i--) {\nlet carry = 0; // 进位\nlet product = ''; // 当前位的乘积")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("// 从 b 的最后一位开始遍历\nfor (let j = bStr.length - 1; j >= 0; j--) {\n  const digitA = parseInt(aStr[i]); // 数字 a 的当前位数值\n  const digitB = parseInt(bStr[j]); // 数字 b 的当前位数值\n\n  // 计算当前位的乘积，加上进位\n  const partialProduct = digitA * digitB + carry;\n  // 更新进位\n  carry = Math.floor(partialProduct / 10);\n  // 将当前位的结果添加到当前乘积的开头\n  product = (partialProduct % 10) + product;\n}\n\n// 若进位大于0，则将其添加到当前乘积的开头\nif (carry > 0) {\n  product = carry + product;\n}\n\n// 添加0，相当于当前位乘积的位数向左移动\nproduct += '0'.repeat(aStr.length - i - 1);\n// 将当前位的乘积添加到临时数组中\nproducts.push(product);\n")])])]),t("p",[n._v("}")]),n._v(" "),t("p",[n._v("// 将各位乘积相加，得到最终结果\nlet result = '0';\nfor (const product of products) {\nresult = add(result, product);\n}")]),n._v(" "),t("p",[n._v("// 去除首尾无效的0，并返回结果\nreturn trimLeadingAndTrailingZeros(result);\n}")]),n._v(" "),t("p",[n._v("// 示例\nconst a = '0.1';\nconst b = '0.2';\nconst sum = add(a, b);\nconsole.log(sum); // 输出：\"0.3\"")]),n._v(" "),t("p",[n._v('const product = multiply(a, b);\nconsole.log(product); // 输出："0.02"')]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("\n[//]: # (3、调整计算顺序：有时，通过重新排列计算顺序可以减少舍入误差的影响。)\n\n[//]: # (   例如，如果某个计算顺序导致大数与小数相加，可以尽量将相似大小的数值进行相加，然后再进行舍入。这样可以减小舍入误差的累积效应。)\n<br/><br/>\n\n3、**使用整数计算**：对于需要高精度的货币计算等场景，可以将小数转换为整数，进行整数计算，然后再将结果转换回小数形式。\n   这可以避免浮点数精度问题，因为整数计算没有舍入误差。\n<br/>\n```javascript\nfunction decimalToIntegerCalculation(a, b, operator) {\n  // 将小数转换成整数\n  const precision = Math.max(getPrecision(a), getPrecision(b));\n  const integerA = a * Math.pow(10, precision);\n  const integerB = b * Math.pow(10, precision);\n\n  // 进行整数运算\n  let result;\n  switch (operator) {\n    case '+':\n      result = integerA + integerB;\n      break;\n    case '-':\n      result = integerA - integerB;\n      break;\n    case '*':\n      result = (integerA * integerB) / Math.pow(10, precision * 2);\n      break;\n    case '/':\n      result = integerA / integerB;\n      break;\n    default:\n      throw new Error(\"Invalid operator\");\n  }\n\n  // 将结果转回小数形式\n  return result / Math.pow(10, precision);\n}\n\n// 获取小数的精度\nfunction getPrecision(number) {\n  const str = number.toString();\n  const decimalIndex = str.indexOf(\".\");\n  return decimalIndex === -1 ? 0 : str.length - decimalIndex - 1;\n}\n\n// 示例\nconst a = 0.1;\nconst b = 0.2;\nconst sum = decimalToIntegerCalculation(a, b, '+');\nconsole.log(sum); // Output: 0.3\n\n")])])])])}),[],!1,null,null,null);t.default=a.exports}}]);